import * as tslib_1 from "tslib";
import { getNativeContext } from '../helpers/get-native-context';
var DEFAULT_OPTIONS = {
    buffer: null,
    channelCount: 2,
    channelCountMode: 'max',
    channelInterpretation: 'speakers',
    detune: 0,
    loop: false,
    loopEnd: 0,
    loopStart: 0,
    playbackRate: 1
};
export var createAudioBufferSourceNodeConstructor = function (createAudioBufferSourceNodeRenderer, createAudioParam, createInvalidStateError, createNativeAudioBufferSourceNode, isNativeOfflineAudioContext, noneAudioDestinationNodeConstructor) {
    return /** @class */ (function (_super) {
        tslib_1.__extends(AudioBufferSourceNode, _super);
        function AudioBufferSourceNode(context, options) {
            if (options === void 0) { options = DEFAULT_OPTIONS; }
            var _this = this;
            var nativeContext = getNativeContext(context);
            var mergedOptions = tslib_1.__assign({}, DEFAULT_OPTIONS, options);
            var nativeNode = createNativeAudioBufferSourceNode(nativeContext, mergedOptions);
            var isOffline = isNativeOfflineAudioContext(nativeContext);
            var audioBufferSourceNodeRenderer = (isOffline) ? createAudioBufferSourceNodeRenderer() : null;
            _this = _super.call(this, context, nativeNode, audioBufferSourceNodeRenderer) || this;
            _this._audioBufferSourceNodeRenderer = audioBufferSourceNodeRenderer;
            _this._detune = createAudioParam(context, isOffline, nativeNode.detune);
            _this._isBufferNullified = false;
            _this._isBufferSet = false;
            _this._nativeNode = nativeNode;
            // Bug #73: Edge, Firefox & Safari do not export the correct values for maxValue and minValue.
            _this._playbackRate = createAudioParam(context, isOffline, nativeNode.playbackRate, 3.4028234663852886e38, -3.4028234663852886e38);
            return _this;
        }
        Object.defineProperty(AudioBufferSourceNode.prototype, "buffer", {
            get: function () {
                if (this._isBufferNullified) {
                    return null;
                }
                return this._nativeNode.buffer;
            },
            set: function (value) {
                // Bug #71: Edge does not allow to set the buffer to null.
                try {
                    this._nativeNode.buffer = value;
                }
                catch (err) {
                    if (value !== null || err.code !== 17) {
                        throw err;
                    }
                    // @todo Create a new internal nativeNode.
                    this._isBufferNullified = (this._nativeNode.buffer !== null);
                }
                // Bug #72: Only Chrome, Edge & Opera do not allow to reassign the buffer yet.
                if (value !== null) {
                    if (this._isBufferSet) {
                        throw createInvalidStateError();
                    }
                    this._isBufferSet = true;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AudioBufferSourceNode.prototype, "onended", {
            get: function () {
                return this._nativeNode.onended;
            },
            set: function (value) {
                this._nativeNode.onended = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AudioBufferSourceNode.prototype, "detune", {
            get: function () {
                return this._detune;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AudioBufferSourceNode.prototype, "loop", {
            get: function () {
                return this._nativeNode.loop;
            },
            set: function (value) {
                this._nativeNode.loop = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AudioBufferSourceNode.prototype, "loopEnd", {
            get: function () {
                return this._nativeNode.loopEnd;
            },
            set: function (value) {
                this._nativeNode.loopEnd = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AudioBufferSourceNode.prototype, "loopStart", {
            get: function () {
                return this._nativeNode.loopStart;
            },
            set: function (value) {
                this._nativeNode.loopStart = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AudioBufferSourceNode.prototype, "playbackRate", {
            get: function () {
                return this._playbackRate;
            },
            enumerable: true,
            configurable: true
        });
        AudioBufferSourceNode.prototype.start = function (when, offset, duration) {
            if (when === void 0) { when = 0; }
            if (offset === void 0) { offset = 0; }
            this._nativeNode.start(when, offset, duration);
            if (this._audioBufferSourceNodeRenderer !== null) {
                this._audioBufferSourceNodeRenderer.start = (duration === undefined) ? [when, offset] : [when, offset, duration];
            }
        };
        AudioBufferSourceNode.prototype.stop = function (when) {
            if (when === void 0) { when = 0; }
            this._nativeNode.stop(when);
            if (this._audioBufferSourceNodeRenderer !== null) {
                this._audioBufferSourceNodeRenderer.stop = when;
            }
        };
        return AudioBufferSourceNode;
    }(noneAudioDestinationNodeConstructor));
};
//# sourceMappingURL=/build/es2015/factories/audio-buffer-source-node-constructor.js.map